{"name":"Perl-device-smbus","tagline":"Interface to I2C SMBus protocol built around libi2c-dev to access I2C Device registers","body":"# NAME\r\n\r\nDevice::SMBus - Control and read hardware devices with i2c(SMBus)\r\n\r\n# VERSION\r\n\r\nversion 1.13\r\n\r\n# SYNOPSIS\r\n\r\n    use Device::SMBus;\r\n    $dev = Device::SMBus->new(\r\n      I2CBusDevicePath => '/dev/i2c-1',\r\n      I2CDeviceAddress => 0x1e,\r\n    );\r\n    print $dev->readByteData(0x20);\r\n\r\n# DESCRIPTION\r\n\r\nThis is a perl interface to smbus interface using libi2c-dev library. \r\n\r\nPrerequisites:\r\n\r\nFor Debian and derivative distros(including raspbian) use the following to install dependencies:\r\n\r\n    sudo apt-get install libi2c-dev i2c-tools build-essential\r\n\r\nIf you are using Angstrom Linux use the following:\r\n\r\n    opkg install i2c-tools\r\n    opkg install i2c-tools-dev\r\n\r\nFor ArchLINUX use the following steps:\r\n\r\n    pacman -S base-devel\r\n    pacman -S i2c-tools\r\n\r\nSpecial Instructions for enabling the I2C driver on a Raspberry Pi:\r\n\r\nYou will need to comment out the driver from the blacklist. currently the\r\nI2C driver isn't being loaded.\r\n\r\n     sudo vim /etc/modprobe.d/raspi-blacklist.conf\r\n\r\nReplace this line \r\n\r\n     blacklist i2c-bcm2708\r\n\r\nwith this\r\n\r\n     #blacklist i2c-bcm2708\r\n\r\nYou now need to edit the modules conf file.\r\n\r\n     sudo vim /etc/modules\r\n\r\nAdd these two lines;\r\n\r\n     i2c-dev\r\n     i2c-bcm2708\r\n\r\nNow run this command(replace 1 with 0 for older model Pi)\r\n\r\n     sudo i2cdetect -y 1\r\n\r\nIf that doesnt work on your system you may alternatively use this:\r\n\r\n     sudo i2cdetect -r 1\r\n\r\nyou should now see the addresses of the i2c devices connected to your i2c bus\r\n\r\n# ATTRIBUTES\r\n\r\n## I2CBusDevicePath\r\n\r\nDevice path of the I2C Device. \r\n\r\n    * On Raspberry Pi Model A this would usually be /dev/i2c-0 if you are using the default pins.\r\n    * On Raspberry Pi Model B this would usually be /dev/i2c-1 if you are using the default pins.\r\n\r\n## I2CDeviceAddress\r\n\r\nThis is the Address of the device on the I2C bus, this is usually available in the device Datasheet.\r\n\r\n    * for /dev/i2c-0 look at output of `sudo i2cdetect -y 0' \r\n    * for /dev/i2c-1 look at output of `sudo i2cdetect -y 1' \r\n\r\n# METHODS\r\n\r\n## fileError\r\n\r\nreturns IO::Handle->error() for the device handle since the last clearerr\r\n\r\n## writeQuick\r\n\r\n    $self->writeQuick($value)\r\n\r\nThis sends a single bit to the device, at the place of the Rd/Wr bit.\r\n\r\n## readByte\r\n\r\n    $self->readByte()\r\n\r\nThis reads a single byte from a device, without specifying a device\r\nregister. Some devices are so simple that this interface is enough; for\r\nothers, it is a shorthand if you want to read the same register as in\r\nthe previous SMBus command\r\n\r\n## writeByte\r\n\r\n    $self->writeByte()\r\n\r\nThis operation is the reverse of readByte: it sends a single byte\r\nto a device. \r\n\r\n## readByteData\r\n\r\n    $self->readByteData($register_address)\r\n\r\nThis reads a single byte from a device, from a designated register.\r\nThe register is specified through the Comm byte.\r\n\r\n## writeByteData\r\n\r\n    $self->writeByteData($register_address,$value)\r\n\r\nThis writes a single byte to a device, to a designated register. The\r\nregister is specified through the Comm byte. This is the opposite of\r\nthe Read Byte operation.\r\n\r\n## readNBytes\r\n\r\n    $self->readNBytes($lowest_byte_address, $number_of_bytes);\r\n\r\nRead together N bytes of Data in linear register order. i.e. to read from 0x28,0x29,0x2a \r\n\r\n    $self->readNBytes(0x28,3);\r\n\r\n## readWordData\r\n\r\n    $self->readWordData($register_address)\r\n\r\nThis operation is very like Read Byte; again, data is read from a\r\ndevice, from a designated register that is specified through the Comm\r\nbyte. But this time, the data is a complete word (16 bits).\r\n\r\n## writeWordData\r\n\r\n    $self->writeWordData($register_address,$value)\r\n\r\nThis is the opposite of the Read Word operation. 16 bits\r\nof data is written to a device, to the designated register that is\r\nspecified through the Comm byte.\r\n\r\n## processCall\r\n\r\n    $self->processCall($register_address,$value)\r\n\r\nThis command selects a device register (through the Comm byte), sends\r\n16 bits of data to it, and reads 16 bits of data in return.\r\n\r\n## writeBlockData\r\n\r\n    $self->writeBlockData($register_address, $values)\r\n\r\nWrites a maximum of 32 bytes in a single block to the i2c device.  The supplied $values should be\r\nan array ref containing the bytes to be written.\r\n\r\nThe register address should be one that is at the beginning of a contiguous block of registers of equal length\r\nto the array of values passed.  Not adhering to this will almost certainly result in unexpected behaviour in\r\nthe device.\r\n\r\n## readBlockData\r\n\r\n    $self->readBlockData($register_address, $numBytes)\r\n\r\nRead $numBytes form the given register address,\r\ndata is returned as array\r\n\r\nThe register address is often 0x00 or the value your device expects\r\n\r\ncommon usage with micro controllers that receive and send large amounts of data:\r\nthey almost always needs a 'command' to be written to them then they send a response:\r\ne.g:\r\n1) send 'command' with writeBlockData, or writeByteData, for example 'get last telegram'\r\n2) read 'response' with readBlockData of size $numBytes, controller is sending the last telegram\r\n\r\n## DEMOLISH\r\n\r\nDestructor\r\n\r\n# CONSTANTS\r\n\r\n## I2C\\_SLAVE\r\n\r\n# CREATING YOUR OWN CHIPSET DRIVERS\r\n\r\nWriting your own chipset driver for your own i2c devices is quiet simple. You just need to know the i2c address of your device and the registers that you need to read or write. Follow the manual at [Device::SMBus::Manual](https://metacpan.org/pod/Device::SMBus::Manual).\r\n\r\n# NOTES\r\n\r\nI wrote this library for my Quadrotor project for controlling PWM Wave Generators ( ESC or DC motor controller ), Accelerometer, Gyroscope, Magnetometer, Altimeter, Temperature Sensor etc. However this module can also be used by anyone who wishes to read or control motherboard devices on I2C like laptop battery system, temperature or voltage sensors, fan controllers, lid switches, clock chips. Some PCI add in cards may connect to a SMBus segment.\r\n\r\nThe SMBus was defined by Intel in 1995. It carries clock, data, and instructions and is based on Philips' I2C serial bus protocol. Its clock frequency range is 10 kHz to 100 kHz. (PMBus extends this to 400 kHz.) Its voltage levels and timings are more strictly defined than those of I2C, but devices belonging to the two systems are often successfully mixed on the same bus. SMBus is used as an interconnect in several platform management standards including: ASF, DASH, IPMI. \r\n\r\n\\-wiki\r\n\r\n# USAGE\r\n\r\n- This module provides a simplified object oriented interface to the libi2c-dev library for accessing electronic peripherals connected on the I2C bus. It uses Moose.\r\n\r\n# SEE ALSO\r\n\r\n- [Moose](https://metacpan.org/pod/Moose)\r\n- [IO::File](https://metacpan.org/pod/IO::File)\r\n- [Fcntl](https://metacpan.org/pod/Fcntl)\r\n\r\n# SUPPORT\r\n\r\n## Bugs / Feature Requests\r\n\r\nPlease report any bugs or feature requests through github at \r\n[https://github.com/shantanubhadoria/perl-device-smbus/issues](https://github.com/shantanubhadoria/perl-device-smbus/issues).\r\nYou will be notified automatically of any progress on your issue.\r\n\r\n## Source Code\r\n\r\nThis is open source software.  The code repository is available for\r\npublic review and contribution under the terms of the license.\r\n\r\n[https://github.com/shantanubhadoria/perl-device-smbus](https://github.com/shantanubhadoria/perl-device-smbus)\r\n\r\n    git clone git://github.com/shantanubhadoria/perl-device-smbus.git\r\n\r\n# AUTHOR\r\n\r\nShantanu Bhadoria <shantanu@cpan.org> [https://www.shantanubhadoria.com](https://www.shantanubhadoria.com)\r\n\r\n# CONTRIBUTORS\r\n\r\n- Jonathan Stowe <jns+git@gellyfish.co.uk>\r\n- Neil Bowers <neil@bowers.com>\r\n- Shantanu Bhadoria <shantanu att cpan dott org>\r\n- wfreller <wolfgang@freller.at>\r\n\r\n# COPYRIGHT AND LICENSE\r\n\r\nThis software is copyright (c) 2015 by Shantanu Bhadoria.\r\n\r\nThis is free software; you can redistribute it and/or modify it under\r\nthe same terms as the Perl 5 programming language system itself.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}